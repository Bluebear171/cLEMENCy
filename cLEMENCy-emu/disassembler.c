//
//  disassembler.c
//  cLEMENCy disassembler commands
//
//  Created by Lightning on 2016/10/23.
//  Copyright (c) 2017 Lightning. All rights reserved.
//

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "cpu.h"
#include "memory.h"
#include "debug.h"
#include "clem-instructions.h"
#include "recordstate.h"

typedef struct OpcodeStruct
{
	unsigned long Opcode;
	unsigned long Mask;
	char *Name;
	int FiveBits;
	short BitCount;
	short Format;
} OpcodeStruct;

OpcodeStruct Opcodes[] = {
//file auto generated by create-disas-data.py in Makefile
#include "disassembler_opcodes.h"
{0xff, 0, 0, -1, 0, 0}
};

int SizeOfOpcode(int Location)
{
	int CurInstCount;
	int FiveBits;
	int MatchEntry = -1;
	unsigned long FullOpcode;
	unsigned long CurInst;

	//return the size of the opcode at the specified location

	//get the maximum number of bytes for the instruction
	CurInst = _Read18(Location, 0);
	FiveBits = CurInst >> 13;

	//if FiveBits is invalid then don't look
	if(FiveBits >= 0xff)
		return 0;

	//look up 5 bit match
	MatchEntry = -1;
	for(CurInstCount = 0; Opcodes[CurInstCount].FiveBits <= FiveBits; CurInstCount++)
	{
		//if we hit the end then return
		if(Opcodes[CurInstCount].FiveBits == -1)
			break;
		//if too high then exit, if not matching then continue
		else if(FiveBits < Opcodes[CurInstCount].FiveBits)
			break;
		else if(FiveBits != Opcodes[CurInstCount].FiveBits)
			continue;

		//shift the opcode for the instruction size and check if it matches the mask
		FullOpcode = CurInst;
		if(Opcodes[CurInstCount].BitCount == 27)
			FullOpcode = (FullOpcode << 9) | _Read9(Location + 2, 0);
		else if(Opcodes[CurInstCount].BitCount == 36)
			FullOpcode = (((unsigned long)_Read27(Location, 0)) << 9) | _Read9(Location + 3, 0);
		else if(Opcodes[CurInstCount].BitCount == 54)
			FullOpcode = (((unsigned long)_Read27(Location, 0)) << 27) | ((unsigned long)_Read27(Location + 3, 0));

		//if the mask matches the opcode then return the size we found
		if((FullOpcode & Opcodes[CurInstCount].Mask) == Opcodes[CurInstCount].Opcode)
			return Opcodes[CurInstCount].BitCount / 9;
	}

	return 0;
}

void DisassembleInstructions(int Location, int InstCount, RecordStateStruct *RecordState)
{
	int CurCount;
	int CurInstCount;
	int FiveBits;
	int MatchEntry = -1;
	unsigned long FullOpcode;
	unsigned long CurInst;
	char OpcodeData[256];
	char FullOpcodeStr[20];
	DebugBreakpointStruct *BP;
	char *MapName;
	int BranchCond;
	int BranchHit;
	int RegisterUsed[4];	//load/store doesn't display all. 0 is always result and pulled from after state
	int FlagsUpdated;
	int FlagsToCheck;
	int NameSpaceWidth;
	char PeriodChar;
	int PeriodWidth;

	//print the instruction count requested
	for(CurCount = 0; CurCount < InstCount; CurCount++)
	{
		BranchHit = 0;

		//reset registers to unused
		RegisterUsed[0] = -1;
		RegisterUsed[1] = -1;
		RegisterUsed[2] = -1;
		RegisterUsed[3] = -1;
		FlagsUpdated = 0;

		//get the maximum number of bytes for the instruction
		CurInst = _Read18(Location, 0);
		FiveBits = CurInst >> 13;

		//if FiveBits is invalid then don't look
		if(FiveBits >= 0xff)
		{
			printf("%07x: Disassembly Error\n", Location);
			break;
		}

		//look up 5 bit match
		MatchEntry = -1;
		for(CurInstCount = 0; Opcodes[CurInstCount].FiveBits <= FiveBits; CurInstCount++)
		{
			//if we hit the end then return
			if(Opcodes[CurInstCount].FiveBits == -1)
				break;
			//if too high then exit, if not matching then continue
			else if(FiveBits < Opcodes[CurInstCount].FiveBits)
				break;
			else if(FiveBits != Opcodes[CurInstCount].FiveBits)
				continue;

			//shift the opcode for the instruction size and check if it matches the mask
			FullOpcode = CurInst;
			if(Opcodes[CurInstCount].BitCount == 27)
			{
				FullOpcode = (FullOpcode << 9) | _Read9(Location + 2, 0);
				sprintf(FullOpcodeStr, "%07lx       ", FullOpcode);
			}
			else if(Opcodes[CurInstCount].BitCount == 36)
			{
				FullOpcode = (((unsigned long)_Read27(Location, 0)) << 9) | _Read9(Location + 3, 0);
				sprintf(FullOpcodeStr, "%09lx     ", FullOpcode);
			}
			else if(Opcodes[CurInstCount].BitCount == 54)
			{
				FullOpcode = (((unsigned long)_Read27(Location, 0)) << 27) | ((unsigned long)_Read27(Location + 3, 0));
				sprintf(FullOpcodeStr, "%014lx", FullOpcode);
			}
			else
			{
				//18 bits
				sprintf(FullOpcodeStr, "%05lx         ", FullOpcode);
			}

			if((FullOpcode & Opcodes[CurInstCount].Mask) == Opcodes[CurInstCount].Opcode)
			{
				MatchEntry = CurInstCount;
				break;
			}
		}

		//if no match then not an instruction
		if(MatchEntry == -1)
		{
			printf("%07x: Disassembly Error\n", Location);
			break;
		}

		//found a match, print the opcode
		OpcodeData[0] = 0;
		switch(Opcodes[MatchEntry].Format)
		{
			case 0:
				if(Opcodes[MatchEntry].FiveBits == CLEM_RE)
					RegisterUsed[1] = 30;

				//do nothing, just have the opcode name to print
				break;

			case 1:
			case 14:
				//rA, rB, rC
				if(FullOpcode & 1)
					FlagsUpdated = 1;

				RegisterUsed[0] = (FullOpcode >> 15) & 0x1f;
				RegisterUsed[1] = (FullOpcode >> 10) & 0x1f;
				RegisterUsed[2] = (FullOpcode >> 5) & 0x1f;

				sprintf(OpcodeData, "%s, %s, %s",
						RegisterStr[(FullOpcode >> 15) & 0x1f],	//rA
						RegisterStr[(FullOpcode >> 10) & 0x1f],	//rB
						RegisterStr[(FullOpcode >> 5) & 0x1f]);	//rC
				break;

			case 2:
				//rA, rB, Immediate
				if(FullOpcode & 1)
					FlagsUpdated = 1;

				RegisterUsed[0] = (FullOpcode >> 15) & 0x1f;
				RegisterUsed[1] = (FullOpcode >> 10) & 0x1f;

				sprintf(OpcodeData, "%s, %s, 0x%02lx",
						RegisterStr[(FullOpcode >> 15) & 0x1f],	//rA
						RegisterStr[(FullOpcode >> 10) & 0x1f],	//rB
						(FullOpcode >> 3) & 0x7f);	//Immediate
				break;

			case 15:
				//rA, rB, Immediate
				if(FullOpcode & 1)
					FlagsUpdated = 1;

				RegisterUsed[0] = (FullOpcode >> 15) & 0x1f;
				RegisterUsed[1] = (FullOpcode >> 10) & 0x1f;

				sprintf(OpcodeData, "%s, %s, 0x%lx",
						RegisterStr[(FullOpcode >> 15) & 0x1f],	//rA
						RegisterStr[(FullOpcode >> 10) & 0x1f],	//rB
						(FullOpcode >> 3) & 0x7f);	//Immediate
				break;

			case 3:
			{
				//load/store
				//rA, [rB + Offset, RegCount]
				unsigned int OpOffset, OpRegCount;
				OpOffset = (FullOpcode >> 3) & 0x7ffffff;
				OpRegCount = (FullOpcode >> 32) & 0x1f;

				RegisterUsed[1] = (FullOpcode >> 42) & 0x1f;
				RegisterUsed[2] = (FullOpcode >> 37) & 0x1f;

				sprintf(OpcodeData, "%s, [%s", RegisterStr[(FullOpcode >> 42) & 0x1F], RegisterStr[(FullOpcode >> 37) & 0x1F]);
				if(OpOffset)
				{
					if(OpOffset & 0x4000000)
					{
						OpOffset = -OpOffset & 0x7ffffff;
						sprintf(OpcodeData, "%s - 0x%x", OpcodeData, OpOffset);
					}
					else
						sprintf(OpcodeData, "%s + 0x%x", OpcodeData, OpOffset);
				}
				if(OpRegCount)
					sprintf(OpcodeData, "%s, %d", OpcodeData, OpRegCount+1);
				strcat(OpcodeData, "]");
				break;
			}

			case 4:
				if(FullOpcode & 1)
					FlagsUpdated = 1;

				//fall through!

			case 12:
				//rA, rB
				//fall through and let case 5 catch everything
				FullOpcode >>= 3;

			case 13:
				//shift and let case 5 handle it
				FullOpcode >>= 5;

			case 5:
				//rA, rB
				if(Opcodes[MatchEntry].FiveBits == CLEM_CM)
				{
					RegisterUsed[1] = (FullOpcode >> 5) & 0x1f;
					RegisterUsed[2] = (FullOpcode >> 0) & 0x1f;
				}
				else
				{
					RegisterUsed[0] = (FullOpcode >> 5) & 0x1f;
					RegisterUsed[1] = (FullOpcode >> 0) & 0x1f;
				}

				sprintf(OpcodeData, "%s, %s",
						RegisterStr[(FullOpcode >> 5) & 0x1f],	//rA
						RegisterStr[(FullOpcode) & 0x1f]);	//rB
				break;

			case 6:
			{
				//show flag state
				FlagsUpdated = 2;

				//branch conditional
				int OpOffset;
				OpOffset = (FullOpcode & 0x1ffff);
				if(OpOffset & 0x10000)
				{
					OpOffset = -OpOffset & 0x1ffff;
					sprintf(OpcodeData, "-0x%x (0x%07x)", OpOffset, Location - OpOffset);
				}
				else
					sprintf(OpcodeData, "+0x%x (0x%07x)", OpOffset, Location + OpOffset);

				//determine the condition and then see if it is satisfied
				if(CPU_PC != (unsigned int)Location)
					break;
				BranchCond = (FullOpcode >> 17) & 0x0F;

				if(RecordState)
					FlagsToCheck = RecordState->BeforeState.Flags;
				else
					FlagsToCheck = CPU_FLAGS;

				switch(BranchCond)
				{
					case BRANCH_COND_NOT_EQUAL:
						if(!(FlagsToCheck & CPU_FLAG_ZERO))
							BranchHit = 1;
						break;

					case BRANCH_COND_EQUAL:
						if(FlagsToCheck & CPU_FLAG_ZERO)
							BranchHit = 1;
						break;

					case BRANCH_COND_LESS_THAN:
						//CARRY == 1 && EQUAL == 0
						if((FlagsToCheck & CPU_FLAG_CARRY) && !(FlagsToCheck & CPU_FLAG_ZERO))
							BranchHit = 1;
						break;

					case BRANCH_COND_LESS_THAN_OR_EQUAL:
						//CARRY == 1 || EQUAL == 1
						if((FlagsToCheck & CPU_FLAG_ZERO) || (FlagsToCheck & CPU_FLAG_CARRY))
							BranchHit = 1;
						break;

					case BRANCH_COND_GREATER_THAN:
						//CARRY == 0 && EQUAL == 0
						if(!(FlagsToCheck & CPU_FLAG_ZERO) && !(FlagsToCheck & CPU_FLAG_CARRY))
							BranchHit = 1;
						break;

					case BRANCH_COND_GREATER_THAN_OR_EQUAL:
						//CARRY == 0 || EQUAL == 1
						if(!(FlagsToCheck & CPU_FLAG_CARRY) || (FlagsToCheck & CPU_FLAG_ZERO))
							BranchHit = 1;
						break;

					case BRANCH_COND_NOT_OVERFLOW:
						//not overflow
						if(!(FlagsToCheck & CPU_FLAG_OVERFLOW))
							BranchHit = 1;
						break;

					case BRANCH_COND_OVERFLOW:
						//overflow
						if(FlagsToCheck & CPU_FLAG_OVERFLOW)
							BranchHit = 1;
						break;

					case BRANCH_COND_NOT_SIGNED:
						//not signed
						if(!(FlagsToCheck & CPU_FLAG_SIGNED))
							BranchHit = 1;
						break;

					case BRANCH_COND_SIGNED:
						//signed
						if(FlagsToCheck & CPU_FLAG_SIGNED)
							BranchHit = 1;
						break;

					case BRANCH_COND_SIGNED_LESS_THAN:
						//SIGNED != OVERFLOW
						if(((FlagsToCheck & CPU_FLAG_SIGNED) >> 1) != (FlagsToCheck & CPU_FLAG_OVERFLOW))
							BranchHit = 1;
						break;

					case BRANCH_COND_SIGNED_LESS_THAN_OR_EQUAL:
						//EQ || SIGNED != OVERFLOW
						if((FlagsToCheck & CPU_FLAG_ZERO) || (((FlagsToCheck & CPU_FLAG_SIGNED) >> 1) != (FlagsToCheck & CPU_FLAG_OVERFLOW)))
							BranchHit = 1;
						break;

					case BRANCH_COND_SIGNED_GREATER_THAN:
						//EQ == 0 && SIGNED == OVERFLOW
						if(!(FlagsToCheck & CPU_FLAG_ZERO) && (((FlagsToCheck & CPU_FLAG_SIGNED) >> 1) == (FlagsToCheck & CPU_FLAG_OVERFLOW)))
							BranchHit = 1;
						break;

					case BRANCH_COND_SIGNED_GREATER_THAN_OR_EQUAL:
						//SIGNED == OVERFLOW
						if(((FlagsToCheck & CPU_FLAG_SIGNED) >> 1) == (FlagsToCheck & CPU_FLAG_OVERFLOW))
							BranchHit = 1;
						break;

					case BRANCH_COND_ALWAYS:
						BranchHit = 1;
						break;
				}

				break;
			}

			case 7:
			case 17:
			{
				int OpOffset = FullOpcode & 0x7ffffff;
				int NewLocation;
				int SignChar;
				if(((FullOpcode >> 29) & 1) == 0)
				{
					if(OpOffset & 0x4000000)
					{
						OpOffset = -OpOffset & 0x7ffffff;
						NewLocation = Location - OpOffset;
						SignChar = '-';
					}
					else
					{
						NewLocation = Location + OpOffset;
						SignChar = '+';
					}

					if(((FullOpcode >> 30) & 1) == 1)
					{
						MapName = GetMapName(NewLocation);
						if(MapName)
						{
							snprintf(OpcodeData, sizeof(OpcodeData) - 1, "%c0x%x (%s)", SignChar, OpOffset, MapName);
							OpcodeData[sizeof(OpcodeData) - 1] = 0;
						}
						else
							sprintf(OpcodeData, "%c0x%x (0x%07x)", SignChar, OpOffset, NewLocation);
					}
					else
						sprintf(OpcodeData, "%c0x%x (0x%07x)", SignChar, OpOffset, NewLocation);
				}
				else
				{
					if(((FullOpcode >> 30) & 1) == 1)
					{
						MapName = GetMapName(OpOffset);
						if(MapName)
						{
							snprintf(OpcodeData, sizeof(OpcodeData) - 1, "%s", MapName);
							OpcodeData[sizeof(OpcodeData) - 1] = 0;
						}
						else
							sprintf(OpcodeData, "0x%x", OpOffset);
					}
					else
						sprintf(OpcodeData, "0x%x", OpOffset);
				}
				break;
			}

			case 8:
				RegisterUsed[0] = (FullOpcode >> 17) & 0x1f;
				sprintf(OpcodeData, "%s, 0x%lx", RegisterStr[(FullOpcode >> 17) & 0x1F], FullOpcode & 0x1ffff);
				break;

			case 11:
				if(Opcodes[MatchEntry].FiveBits == CLEM_CMI)
					RegisterUsed[1] = (FullOpcode >> 14) & 0x1f;
				else
					RegisterUsed[0] = (FullOpcode >> 14) & 0x1f;

				sprintf(OpcodeData, "%s, 0x%lx", RegisterStr[(FullOpcode >> 14) & 0x1F], FullOpcode & 0x3fff);
				break;

			case 9:
				//branch register conditional
				RegisterUsed[1] = (FullOpcode >> 3) & 0x1f;
				sprintf(OpcodeData, "%s", RegisterStr[(FullOpcode >> 3) & 0x1F]);
				break;

			case 10:
			{
				//memory protection
				//rA, rB, flags
				if(strcmp(Opcodes[MatchEntry].Name, "rmp") == 0)
				{
					RegisterUsed[0] = (FullOpcode >> 15) & 0x1f;
					RegisterUsed[1] = (FullOpcode >> 10) & 0x1f;

					sprintf(OpcodeData, "%s, %s", RegisterStr[(FullOpcode >> 15) & 0x1F],
								RegisterStr[(FullOpcode >> 10) & 0x1F]);
				}
				else
				{
					RegisterUsed[1] = (FullOpcode >> 15) & 0x1f;
					RegisterUsed[2] = (FullOpcode >> 10) & 0x1f;
					RegisterUsed[3] = (FullOpcode >> 5) & 0x1f;

					char *FlagType[] = {"N", "R", "RW", "E"};
					sprintf(OpcodeData, "%s, %s, %s", RegisterStr[(FullOpcode >> 15) & 0x1F],
								RegisterStr[(FullOpcode >> 10) & 0x1F],
								FlagType[(FullOpcode >> 7) & 3]);
				}
				break;
			}

			case 16:
				RegisterUsed[1] = (FullOpcode >> 1) & 0x1f;

				sprintf(OpcodeData, "%s", RegisterStr[(FullOpcode >> 1) & 0x1F]);
				break;

			default:
				break;	//invalid, exit

		}

		//if we have a breakpoint then see what color to set
		BP = (DebugBreakpointStruct *)DebugCheckMemoryAccess(Location, 1, DEBUG_READ | DEBUG_WRITE | DEBUG_EXECUTE);
		if(BP)
		{
			if(BP->Type & DEBUG_EXECUTE)
				write(1, "\x1b[31;1m",7);
			else if(BP->Type & DEBUG_READ)
				write(1, "\x1b[34;1m",7);
			else if(BP->Type & DEBUG_WRITE)
				write(1, "\x1b[36;1m",7);
		}

		//bold it
		if(BranchHit)
			write(1, "\x1b[1m",4);

		//get map name and padding
		MapName = GetMapName(Location);
		NameSpaceWidth = 23;
		if(!MapName)
			MapName = "";
		else
			NameSpaceWidth = NameSpaceWidth - strlen(MapName) - 3;
		if(NameSpaceWidth < 0)
			NameSpaceWidth = 0;

		//print out the line
		PeriodWidth = 6 - strlen(Opcodes[MatchEntry].Name);
		if(FlagsUpdated == 1)
		{
			PeriodChar = '.';
			PeriodWidth--;
		}
		else
			PeriodChar = 0;

		//this is starting to look painful
		printf("%07x%c%c%s%c: %-*c %s  %s%-*c  %-20s", Location,
			(strlen(MapName)) ? ' ': 0, (strlen(MapName)) ? '<': 0, MapName, (strlen(MapName)) ? '>': 0,
			NameSpaceWidth, ' ', FullOpcodeStr, Opcodes[MatchEntry].Name, PeriodWidth, PeriodChar, OpcodeData);

		//if we have a state then show registers
		if(RecordState)
		{
				printf("  \x1b[36;1m");
				if(RegisterUsed[0] != -1)
					printf("%s = %07x  ", RegisterStr[RegisterUsed[0]], RecordState->AfterState.R[RegisterUsed[0]]);
				if(RegisterUsed[1] != -1)
					printf("%s (%07x)  ", RegisterStr[RegisterUsed[1]], RecordState->BeforeState.R[RegisterUsed[1]]);
				if((RegisterUsed[2] != -1) && (RegisterUsed[1] != RegisterUsed[2]))
					printf("%s (%07x)  ", RegisterStr[RegisterUsed[2]], RecordState->BeforeState.R[RegisterUsed[2]]);
				if((RegisterUsed[3] != -1) && (RegisterUsed[1] != RegisterUsed[2]) && (RegisterUsed[1] != RegisterUsed[3]))
					printf("%s (%07x)  ", RegisterStr[RegisterUsed[3]], RecordState->BeforeState.R[RegisterUsed[3]]);
				if(FlagsUpdated)
				{
					printf("FL: ");
					if(RecordState->AfterState.Flags & CPU_FLAG_SIGNED)
						printf("S");
					if(RecordState->AfterState.Flags & CPU_FLAG_OVERFLOW)
						printf("O");
					if(RecordState->AfterState.Flags & CPU_FLAG_CARRY)
						printf("C");
					if(RecordState->AfterState.Flags & CPU_FLAG_ZERO)
						printf("Z");
				}
		}

		printf("\n");
		if(BP || BranchHit || RecordState)
			write(1, "\x1b[39;0m\x1b[39;49m",15);

		Location += (Opcodes[MatchEntry].BitCount / 9);
	}

	return;
}
